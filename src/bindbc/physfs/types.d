/*
Copyright (c) 2025 Timur Gafarov.

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
module bindbc.physfs.types;

alias PHYSFS_uint8 = ubyte;
alias PHYSFS_sint8 = byte;
alias PHYSFS_uint16 = ushort;
alias PHYSFS_sint16 = short;
alias PHYSFS_uint32 = uint;
alias PHYSFS_sint32 = int;
alias PHYSFS_uint64 = ulong;
alias PHYSFS_sint64 = long;

struct PHYSFS_File
{
    void* opaque;
}

alias PHYSFS_file = PHYSFS_File;

struct PHYSFS_ArchiveInfo
{
    const(char)* extension;
    const(char)* description;
    const(char)* author;
    const(char)* url;
    int supportsSymlinks;
}

struct PHYSFS_Version
{
    PHYSFS_uint8 major;
    PHYSFS_uint8 minor;
    PHYSFS_uint8 patch;
}

enum ubyte PHYSFS_VERSION_MAJOR = 3;
enum ubyte PHYSFS_VERSION_MINOR = 2;
enum ubyte PHYSFS_VERSION_PATCH = 0;

void PHYSFS_VERSION(ref PHYSFS_Version* x)
{
    x.major = PHYSFS_VERSION_MAJOR;
    x.minor = PHYSFS_VERSION_MINOR;
    x.patch = PHYSFS_VERSION_PATCH;
}

struct PHYSFS_Allocator
{
    extern(C) nothrow
    {
        int function() Init;
        void function() Deinit;
        void* function(PHYSFS_uint64) Malloc;
        void* function(void*, PHYSFS_uint64) Realloc;
        void function(void*) Free;
    }
}

extern(C) nothrow
{
    alias PHYSFS_StringCallback = void function(void*, const(char)*);
    alias PHYSFS_EnumFilesCallback = void function(void*, const(char)*, const(char)*);
}

alias PHYSFS_FileType = int;
enum
{
    PHYSFS_FILETYPE_REGULAR,
    PHYSFS_FILETYPE_DIRECTORY,
    PHYSFS_FILETYPE_SYMLINK,
    PHYSFS_FILETYPE_OTHER
}

struct PHYSFS_Stat
{
    PHYSFS_sint64 filesize;
    PHYSFS_sint64 modtime;
    PHYSFS_sint64 createtime;
    PHYSFS_sint64 accesstime;
    PHYSFS_FileType filetype;
    int readonly;
}

alias PHYSFS_EnumerateCallbackResult = int;
enum
{
    PHYSFS_ENUM_ERROR = -1,
    PHYSFS_ENUM_STOP = 0,
    PHYSFS_ENUM_OK = 1
}

extern(C) nothrow
{
    alias PHYSFS_EnumerateCallback = PHYSFS_EnumerateCallbackResult function(
        void *data,
        const(char)* origdir,
        const(char)* fname);
}

struct PHYSFS_Io
{
    PHYSFS_uint32 version_;
    void* opaque;
    extern(C) nothrow
    {
        PHYSFS_sint64 function(PHYSFS_Io* io, void* buf, PHYSFS_uint64 len) read;
        PHYSFS_sint64 function(PHYSFS_Io* io, const(void)* buffer, PHYSFS_uint64 len) write;
        int function(PHYSFS_Io* io, PHYSFS_uint64 offset) seek;
        PHYSFS_sint64 function(PHYSFS_Io*) tell;
        PHYSFS_sint64 function(PHYSFS_Io*) length;
        PHYSFS_Io* function(PHYSFS_Io*) duplicate;
        int function(PHYSFS_Io*) flush;
        void function(PHYSFS_Io*) destroy;
    }
}

extern(C) nothrow alias UnmountCallback = void function(void*);

alias PHYSFS_ErrorCode = int;
enum
{
    PHYSFS_ERR_OK,
    PHYSFS_ERR_OTHER_ERROR,
    PHYSFS_ERR_OUT_OF_MEMORY,
    PHYSFS_ERR_NOT_INITIALIZED,
    PHYSFS_ERR_IS_INITIALIZED,
    PHYSFS_ERR_ARGV0_IS_NULL,
    PHYSFS_ERR_UNSUPPORTED,
    PHYSFS_ERR_PAST_EOF,
    PHYSFS_ERR_FILES_STILL_OPEN,
    PHYSFS_ERR_INVALID_ARGUMENT,
    PHYSFS_ERR_NOT_MOUNTED,
    PHYSFS_ERR_NOT_FOUND,
    PHYSFS_ERR_SYMLINK_FORBIDDEN,
    PHYSFS_ERR_NO_WRITE_DIR,
    PHYSFS_ERR_OPEN_FOR_READING,
    PHYSFS_ERR_OPEN_FOR_WRITING,
    PHYSFS_ERR_NOT_A_FILE,
    PHYSFS_ERR_READ_ONLY,
    PHYSFS_ERR_CORRUPT,
    PHYSFS_ERR_SYMLINK_LOOP,
    PHYSFS_ERR_IO,
    PHYSFS_ERR_PERMISSION,
    PHYSFS_ERR_NO_SPACE,
    PHYSFS_ERR_BAD_FILENAME,
    PHYSFS_ERR_BUSY,
    PHYSFS_ERR_DIR_NOT_EMPTY,
    PHYSFS_ERR_OS_ERROR,
    PHYSFS_ERR_DUPLICATE,
    PHYSFS_ERR_BAD_PASSWORD,
    PHYSFS_ERR_APP_CALLBACK
}

struct PHYSFS_Archiver
{
    PHYSFS_uint32 version_;
    PHYSFS_ArchiveInfo info;
    extern(C) nothrow
    {
        void* function(
            PHYSFS_Io* io,
            const(char)* name,
            int forWrite,
            int* claimed) openArchive;
        PHYSFS_EnumerateCallbackResult function(
            void* opaque,
            const(char)* dirname,
            PHYSFS_EnumFilesCallback cb,
            const(char)* origdir,
            void* callbackdata) enumerateFiles;
        PHYSFS_Io* function(void* opaque, const(char)* fnm) openRead;
        PHYSFS_Io* function(void* opaque, const(char)* filename) openWrite;
        PHYSFS_Io* function(void* opaque, const(char)* filename) openAppend;
        int function(void* opaque, const(char)* filename) remove;
        int function(void* opaque, const(char)* filename) mkdir;
        int function(void* opaque, const(char)* filename, PHYSFS_Stat* stat) stat;
        void function(void* opaque) closeArchive;
    }
}
